package com.yg.gqlwfdl.dataaccess

import com.yg.gqlwfdl.dataaccess.joins.ClientFieldToJoinMapper
import com.yg.gqlwfdl.dataaccess.joins.JoinRequest
import com.yg.gqlwfdl.dataaccess.joins.JoinedRecordToEntityConverterProvider
import com.yg.gqlwfdl.dataaccess.joins.RecordProvider
import com.yg.gqlwfdl.letIfAny
import com.yg.gqlwfdl.services.Entity
import com.yg.gqlwfdl.services.EntityWrapper
import io.reactiverse.pgclient.PgPool
import io.reactiverse.pgclient.Row
import org.jooq.*
import java.util.concurrent.CompletableFuture

/**
 * A repository providing access to an entity (aka domain model object) (of type [TEntity]), by querying one or more
 * database tables, where a single row (of one or more tables) represents a single entity.
 */
abstract class SingleRowDBEntityRepository<
        TEntity : Entity<TId>, TId : Any, TRecord : TableRecord<TRecord>, TQueryInfo : QueryInfo<TRecord>>(
        create: DSLContext,
        connectionPool: PgPool,
        recordToEntityConverterProvider: JoinedRecordToEntityConverterProvider,
        clientFieldToJoinMapper: ClientFieldToJoinMapper,
        recordProvider: RecordProvider,
        table: Table<TRecord>,
        idField: TableField<TRecord, TId>)
    : DBEntityRepository<TEntity, TId, TRecord, TQueryInfo>(create, connectionPool, recordToEntityConverterProvider,
        clientFieldToJoinMapper, recordProvider, table, idField) {

    /**
     * Creates the entity which this repository provides access to from the passed in [row].
     *
     * @param queryInfo The information about the query from which the entity is to be retrieved, used for example to
     * get at the aliased fields' names.
     * @param row A row containing all the data in a single result row from a query generated by this repository
     * when finding the items it's working with.
     */
    protected abstract fun getEntity(queryInfo: TQueryInfo, row: Row): TEntity

    /**
     * Finds all the records that match the conditions supplied by the passed in [conditionProvider], if any.
     *
     * @param requestInfo Information about the request, such as the fields of the entity which were requested by the
     * client, if the call was made from the context of a client request.
     * @param conditionProvider The object that will supply any conditions that should be added to the query. If null,
     * no conditions are applied, and every record is returned.
     */
    override fun find(requestInfo: EntityRequestInfo?,
                      conditionProvider: ((TQueryInfo) -> List<Condition>)?)
            : CompletableFuture<List<TEntity>> {

        return find(
                entityProvider = this::getEntity,
                entityCreationListener = requestInfo?.entityCreationListener,
                joinRequestSetsProvider = { requestInfo?.getJoinInstanceSets(it) },
                conditionProvider = conditionProvider
        )
    }

    /**
     * Runs a SELECT query on the passed in [queryInfo]'s [primaryTable][QueryInfo.primaryTable], optionally adding
     * joins, soring, limits. Then uses the passed in [entityProvider] to convert the rows to entities of type [TResult].
     *
     * @param TResult The type of entity being returned.
     * @param entityProvider The function to call to convert a [Row] into an entity of type [TResult].
     * @param queryInfo The object which will store information about the query being built up (e.g. the table/field
     * aliases). If omitted, created by default by calling [getQueryInfo].
     * @param entityCreationListener The object to inform as the entities are created. Defaults to null, in which case
     * it's ignored.
     * @param defaultJoinsProvider A function to call to get any joins to add by default. If omitted, populated by
     * calling [getDefaultJoinSets].
     * @param joinRequestSetsProvider A function to call to get the joins being requested, e.g. by a GraphQL request.
     * @param conditionProvider The object that will supply any conditions that should be added to the query. If null,
     * no conditions are applied, and every record is returned.
     * @param customJoiner An optional function that can updated the [SelectJoinStep] being built up by adding more joins
     * to it. Used in cases when completely custom join behaviour is required, e.g. joining to nested (derived) tables
     * in a way that can't be handled by the standard [JoinRequest] object model.
     * @param orderBy An optional list of fields to sort by.
     * @param limit An optional limit to the number of rows to return.
     * @return A [CompletableFuture] which will be completed when the query returns its results, and which will expose
     * the results as a [List] of [TResult] objects.
     */
    protected fun <TResult : Entity<out Any>> find(
            entityProvider: (TQueryInfo, Row) -> TResult,
            queryInfo: TQueryInfo = getQueryInfo(),
            entityCreationListener: EntityCreationListener? = null,
            defaultJoinsProvider: ((TQueryInfo) -> List<JoinInstanceSet<out Record>>?)? = { getDefaultJoinSets(queryInfo) },
            joinRequestSetsProvider: ((TQueryInfo) -> List<JoinInstanceSet<out Record>>?)? = null,
            conditionProvider: ((TQueryInfo) -> List<Condition>)? = null,
            customJoiner: ((TQueryInfo, SelectJoinStep<Record>) -> Unit)? = null,
            orderBy: List<OrderField<out Any>>? = null,
            limit: Int? = null)
            : CompletableFuture<List<TResult>> {

        // Get all the join instance sets required: the default joins plus the requested joins (i.e. those based on the
        // requested client fields).
        val joinInstanceSets = (defaultJoinsProvider?.invoke(queryInfo) ?: listOf())
                .plus(joinRequestSetsProvider?.invoke(queryInfo) ?: listOf())

        // Build up the "SELECT... FROM..." part of the query.
        val select = create.select(queryInfo.getAllFields()).from(queryInfo.primaryTable)

        // Add the joins to the query.
        customJoiner?.invoke(queryInfo, select)
        joinInstanceSets.forEach { set -> set.joinInstances.forEach { it.join(select) } }

        val unorderedQuery = select.withConditions(conditionProvider?.invoke(queryInfo))
        val orderedQuery = orderBy?.letIfAny { unorderedQuery.orderBy(it) } ?: unorderedQuery
        val finalQuery = limit?.let { orderedQuery.limit(it) } ?: orderedQuery

        return finalQuery.fetchRowsAsync().thenApply { rows ->
            // Map the rows to the entities and return them.
            rows.map { row ->
                val entity = entityProvider(queryInfo, row)
                if (entityCreationListener != null) {
                    // We need to inform the listener of all the entities, so inform it of the main entity, then
                    // get all the joined entities and inform it of them too.
                    entityCreationListener.onEntityCreated(entity)

                    if (entity is EntityWrapper<*, *>)
                        entityCreationListener.onEntityCreated(entity.entity)

                    joinInstanceSets
                            .flatMap { it.getJoinedEntities(row, queryInfo, recordProvider, recordToEntityConverterProvider) }
                            .forEach { entityCreationListener.onEntityCreated(it) }
                }
                entity
            }
        }
    }

    /**
     * Gets the join sets which are needed by default by this repository (i.e. regardless of what joins are requested by
     * a client request).
     *
     * The base implementation does nothing, which is the desired behaviour for repositories which work with a single
     * table. However subclasses which work with multiple tables should override this and supply the required join sets.
     */
    protected open fun getDefaultJoinSets(queryInfo: TQueryInfo) = listOf<JoinInstanceSet<out Record>>()
}